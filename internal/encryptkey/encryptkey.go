//Mostly generated by ChatGPT

package encryptkey

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"fmt"

	"golang.org/x/crypto/pbkdf2"
)

func EncryptKey(plaintext []byte, password []byte) ([]byte, []byte, []byte) {
    salt := make([]byte, 25)
    rand.Read(salt)
    key := deriveKey(password, salt)

	// Generate a random IV (Initialization Vector)
	iv := make([]byte, aes.BlockSize)
	if _, err := rand.Read(iv); err != nil {
		fmt.Println("Error generating IV:", err)
		return nil, nil, nil
	}

	// Create a new AES cipher block using the derived key
	block, err := aes.NewCipher(key)
	if err != nil {
		fmt.Println("Error creating AES cipher block:", err)
		return nil, nil, nil
	}

	// Pad the plaintext to a multiple of the block size
	plaintext = addPadding(plaintext, aes.BlockSize)

	// Create a cipher block mode with the AES block and IV
	mode := cipher.NewCBCEncrypter(block, iv)

	// Encrypt the plaintext
	ciphertext := make([]byte, len(plaintext))
	mode.CryptBlocks(ciphertext, plaintext)

	// Print the encrypted text and IV
	fmt.Printf("Encrypted Text: %x\n", ciphertext)
	fmt.Printf("Initialization Vector (IV): %x\n", iv)

    return ciphertext, iv, salt
}

func deriveKey(password []byte, salt []byte) []byte {
	// Use PBKDF2 to derive a key from the password
	key := pbkdf2.Key(password, salt, 10000, 32, sha256.New)
	return key
}

func addPadding(data []byte, blockSize int) []byte {
	padding := blockSize - (len(data) % blockSize)
	padText := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(data, padText...)
}

func DecryptKey(encryptedText []byte, password []byte, iv []byte, salt []byte) ([]byte) {
	// Derive the key using PBKDF2
	key := deriveKey(password, salt)

	// Create a new AES cipher block using the derived key
	block, err := aes.NewCipher(key)
	if err != nil {
		fmt.Println("Error creating AES cipher block:", err)
		return nil
	}

	// Create a cipher block mode with the AES block and IV
	mode := cipher.NewCBCDecrypter(block, iv)

	// Decrypt the ciphertext
	decryptedText := make([]byte, len(encryptedText))
	mode.CryptBlocks(decryptedText, encryptedText)

	// Remove padding from the decrypted text
	decryptedText = removePadding(decryptedText)

	// Print the decrypted text
	fmt.Printf("Decrypted Text: %s\n", decryptedText)

    return decryptedText
}

func removePadding(data []byte) []byte {
	padding := int(data[len(data)-1])
	return data[:len(data)-padding]
}

func GenerateRandomBytes(n int) ([]byte, error) {
	b := make([]byte, n)
	_, err := rand.Read(b)
	// Note that err == nil only if we read len(b) bytes.
	if err != nil {
		return nil, err
	}

	return b, nil
}
